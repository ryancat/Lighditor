{"version":3,"file":"lighditor.js","sources":["webpack:///webpack/bootstrap ca037a366c169fcfaef7","webpack:///./src/lighditor.js","webpack:///./src/lighditor.scss?d0ec","webpack:///./src/lighditor.scss","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ca037a366c169fcfaef7","'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n// Web editor should support\n// 1. Basic type in editor\n// 2. Get/Set cursor position\n// 3. Get/Set selection\n// 4. Get/Set text content\n// 5.\n//\n\nvar _lighditor = require('./lighditor.scss');\n\nvar _lighditor2 = _interopRequireDefault(_lighditor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*:: type Position = {\n  row: number,\n  column: number\n}*/\n/*:: type Selection = {\n  start: Position,\n  end: Position\n}*/\n/*:: type LighditorConfig = {\n  initTextContent: string,\n  viewStartRow: number,\n  viewableRows: number\n  // shouldRender: ?(editorState: LighditorState, oldEditorState: ?LighditorState) => boolean\n}*/\n/*:: type LighditorProps = {\n  element: HTMLElement,\n  config: ?LighditorConfig\n}*/\n/*:: type LighditorState = {\n  textContent: string,\n  selection: {\n    start: Position,\n    end: Position\n  },\n  viewStartRow: number,\n  viewableRows: number\n}*/\n/*:: type RowInfo = {\n  container: Node,\n  row: number\n}*/\n\n\nvar EditorClass = {\n  CONTAINER: 'lighditorContainer',\n  ELEMENT: 'lighditorRawElement',\n  EDITOR_ELEMENT: 'lighditorElement',\n  EDITOR_ROW: 'lighditorRow',\n  EDITOR_NEWLINE: 'lighditorNewline'\n};\n\nvar positionTypeEnum = {\n  START: 'start',\n  END: 'end'\n};\n\n// Feature detection\n/*:: type PositionTypeEnum = $Keys<typeof positionTypeEnum>*/\nvar featureGetSelection = !!window.getSelection;\nvar featureCreateRange = !!document.createRange;\n\nvar lighditorUtil = {\n\n  throttle: function throttle(callback /*: () => mixed*/) {\n    var interval /*: number*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    var lastCalledTimestamp /*: ?number*/ = void 0,\n        timeoutId = void 0;\n\n    function refreshTimeout() {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(function () {\n        lastCalledTimestamp = null;\n      }, interval);\n    }\n\n    function throttled() {\n      if (!lastCalledTimestamp) {\n        lastCalledTimestamp = Date.now();\n        refreshTimeout();\n        callback();\n      }\n    }\n\n    return throttled;\n  }\n};\n\nvar Lighditor = function () {\n  // _openParenthesis: number[]\n  // _processPosition: Position\n  // render: () => mixed\n  // shouldRender: (editorState: LighditorState, oldEditorState: ?LighditorState) => boolean\n\n  function Lighditor(element /*: HTMLElement*/, config /*: LighditorConfig*/) {\n    var _this = this;\n\n    _classCallCheck(this, Lighditor);\n\n    this.element = element;\n    this.editorConfig = config;\n\n    // if (config.shouldRender) {\n    //   this.shouldRender = config.shouldRender\n    // }\n\n    // Error checks\n    if (typeof this.element === 'undefined') {\n      throw new Error('Missing element for editor');\n    }\n\n    // Build the editor DOM\n    this._build();\n\n    // Reset editor state\n    this._resetRender();\n\n    // Attach listeners\n    this._listen();\n\n    // Setup placeholder or init text\n    this.setTextContent(this.editorConfig.initTextContent);\n\n    // For debugging\n    Lighditor.debug(function () {\n      window.lighditor = _this;\n    });\n\n    // this.resetRender()\n    // this.build()\n    // this.listen()\n    // @attachListeners()\n    //\n\n    // Decorate prototype\n    // this.render = lighditorUtil.debounce(this.render.bind(this))\n  }\n\n  // Create a instance of Lighditor class\n\n\n  _createClass(Lighditor, [{\n    key: 'setTextContent',\n\n\n    /***** Setters *****/\n    value: function setTextContent(textContent /*: string*/) /*: void*/ {\n      var oldTextContent = this.editorState.textContent;\n\n      // if (textContent === oldTextContent) {\n      //   return\n      // }\n\n      this._setEditorState(_extends({}, this.editorState, {\n        textContent: textContent\n      }));\n\n      this.onTextContentChange(textContent, oldTextContent);\n    }\n  }, {\n    key: 'setSelection',\n    value: function setSelection(selection /*: Selection*/) /*: void*/ {\n      var oldSelection = this.editorState.selection;\n\n      this._setEditorState(_extends({}, this.editorState, {\n        selection: selection\n      }));\n\n      this.onSelectionChange(selection, oldSelection);\n    }\n\n    /***** Getters *****/\n\n  }, {\n    key: 'getSelection',\n    value: function getSelection() /*: Selection*/ {\n      return this.editorState.selection;\n    }\n  }, {\n    key: 'getTextContent',\n    value: function getTextContent() /*: string*/ {\n      return this.editorState.textContent;\n    }\n  }, {\n    key: 'getCursorPosition',\n    value: function getCursorPosition() /*: Position*/ {\n      return this.getSelection().end;\n    }\n\n    /***** Build and unbuild *****/\n\n  }, {\n    key: '_build',\n    value: function _build() /*: void*/ {\n      var elementParent = this.element.parentElement;\n      if (!elementParent) {\n        throw new Error('Element set to html document is not supported');\n      }\n\n      var wrapperElement /*: HTMLDivElement*/ = document.createElement('div');\n      wrapperElement.classList.add(EditorClass.CONTAINER);\n\n      // Replace with input element\n      elementParent.replaceChild(wrapperElement, this.element);\n      this.element.classList.add(EditorClass.ELEMENT);\n\n      // Make sure the original element is not shown\n      this.element.style.display = 'none';\n      wrapperElement.appendChild(this.element);\n\n      // Create editor\n      this.editorElement = document.createElement('div');\n      this.editorElement.classList.add(EditorClass.EDITOR_ELEMENT);\n\n      // Make editor element editable\n      this.editorElement.setAttribute('contenteditable', 'true');\n      wrapperElement.appendChild(this.editorElement);\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() /*: boolean*/ {\n      this._resetRender();\n      var wrapperElement = this.editorElement.parentElement,\n          elementParent /*: Element*/ = void 0;\n\n      if (!(wrapperElement instanceof HTMLElement)) {\n        Lighditor.warn('The wrapper of editor is not an HTMLElement, which should not happen');\n      }\n\n      if (wrapperElement && wrapperElement.parentElement instanceof Element) {\n        elementParent = wrapperElement.parentElement;\n        elementParent.replaceChild(wrapperElement, this.element);\n      }\n\n      return delete this.editorElement;\n    }\n\n    /***** render and state *****/\n    /**\n     * Render the editor element inner html based on current editor state\n     */\n\n  }, {\n    key: '_render',\n    value: function _render() /*: void*/ {\n      var isTextContentChange /*: boolean*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\n      if (isTextContentChange) {\n        // Render the text content\n        var _textContent /*: string*/ = this.editorState.textContent,\n            textContentRows /*: string[]*/ = _textContent.split('\\n'),\n            html /*: string*/ = '',\n            numOfRows /*: number*/ = textContentRows.length;\n\n        textContentRows.forEach(function (textContentRow, row) {\n          var newLineHTML = row !== numOfRows - 1 ? '<br class=\"' + EditorClass.EDITOR_NEWLINE + '\" data-lighditor-type=\"newline\">' : '';\n          // let newLineHTML = ''\n          html += '<div class=\"' + EditorClass.EDITOR_ROW + '\" data-lighditor-type=\"row\">' + textContentRow + newLineHTML + '</div>';\n        });\n\n        this.editorElement.innerHTML = html;\n      }\n\n      // Attach the current selection/cursor\n      this._applySelection();\n    }\n  }, {\n    key: '_renderParsed',\n    value: function _renderParsed() /*: void*/ {\n\n      // if (this.parser)\n\n    }\n  }, {\n    key: '_resetRender',\n    value: function _resetRender() /*: void*/ {\n      var defaultViewableRows = this.editorConfig.viewableRows;\n\n      this._setEditorState({\n        textContent: '',\n        selection: {\n          start: { row: 0, column: 0 },\n          end: { row: 0, column: 0 }\n        },\n        viewStartRow: 0,\n        viewableRows: defaultViewableRows || Infinity\n      });\n    }\n  }, {\n    key: '_shouldRenderTextContent',\n    value: function _shouldRenderTextContent(editorState /*: LighditorState*/, oldEditorState /*: ?LighditorState*/) /*: boolean*/ {\n      // if (oldEditorState) {\n      //   return editorState.textContent !== oldEditorState.textContent\n      // }\n      // else {\n      //   return true\n      // }\n\n      return !oldEditorState || editorState.textContent !== oldEditorState.textContent;\n    }\n  }, {\n    key: '_shouldRenderSelection',\n    value: function _shouldRenderSelection(editorState /*: LighditorState*/, oldEditorState /*: ?LighditorState*/) /*: boolean*/ {\n      return !oldEditorState || editorState.selection !== oldEditorState.selection;\n    }\n  }, {\n    key: '_setEditorState',\n    value: function _setEditorState(editorState /*: LighditorState*/) /*: void*/ {\n      Lighditor.log('set editor state: ', editorState);\n\n      var oldEditorState = this.editorState;\n\n      this.editorState = _extends({}, editorState);\n\n      this._render(!oldEditorState || this.editorState.textContent !== oldEditorState.textContent);\n\n      // TODO: Considering use virtual dom to render editor\n      // if (this._shouldRenderTextContent(this.editorState, oldEditorState)) {\n      //   this._renderTextConent()\n      // }\n\n      // if (this._shouldRenderSelection(this.editorState, oldEditorState)) {\n      //   this._applySelection()\n      // }\n    }\n\n    /***** Events *****/\n\n  }, {\n    key: '_listen',\n    value: function _listen() /*: void*/ {\n      this.editorElement.addEventListener('keydown', this._handleKeydown.bind(this));\n      this.editorElement.addEventListener('keyup', this._handleKeyup.bind(this));\n      // this.editorElement.addEventListener('paste', this._handlePaste.bind(this))\n      this.editorElement.addEventListener('mouseup', this._handleMouseup.bind(this));\n    }\n\n    /**\n     * Keydown event handler\n     * Special key stroke will be handled here, so that we have full control\n     * of the actually rendered DOM\n     *\n     * @param  {[type]} evt: KeyboardEvent [description]\n     * @return {[type]}      [description]\n     */\n\n  }, {\n    key: '_handleKeydown',\n    value: function _handleKeydown(evt /*: KeyboardEvent*/) {\n      Lighditor.log('_handleKeydown:', evt);\n\n      var cursorPosition /*: Position*/ = this.getCursorPosition();\n\n      if (Lighditor.util.getKeycode(evt) === Lighditor.util.keycode.ENTER) {\n        // When hit enter key, we will simply update the selection and text content\n        // with a newline character. The renderer will be able to pick up and render\n        // the text content with clean format\n        evt.preventDefault();\n\n        // Update the selection state to the new line\n        var newRow /*: number*/ = cursorPosition.row + 1;\n\n        this.setSelection({\n          start: {\n            row: newRow,\n            column: 0\n          },\n          end: {\n            row: newRow,\n            column: 0\n          }\n        });\n\n        // Manually set text content\n        this.setTextContent(this._insertTextAtPosition('\\n', cursorPosition));\n      }\n\n      if (Lighditor.util.getKeycode(evt) === Lighditor.util.keycode.BACKSPACE && cursorPosition.column === 0) {\n        // When hit backspace key at the beginning of a row, Chrome will remove\n        // the new line element at the previous row. Let's add it back\n        evt.preventDefault();\n\n        // Update the selection state to the prev line\n        var _newRow /*: number*/ = Math.max(cursorPosition.row - 1, 0),\n            rowElement = this._getRowElementByIndex(_newRow),\n            newColumn /*: number*/ = rowElement instanceof HTMLElement ? rowElement.textContent.length : 0;\n\n        this.setSelection({\n          start: {\n            row: _newRow,\n            column: newColumn\n          },\n          end: {\n            row: _newRow,\n            column: newColumn\n          }\n        });\n\n        // Manually set text content\n        this.setTextContent(this._removeTextAtPosition(cursorPosition));\n      }\n\n      // switch (Lighditor.util.getKeycode(evt)) {\n      //   case Lighditor.util.keycode.ENTER:\n      //     event.preventDefault()\n\n      //     // When hit enter key, a new line will generated and the rest of the current\n      //     // line will be moved to the new line\n      //     // let newLineFragment = document.createDocumentFragment()\n\n      //     // TODO: use view start rows and viable rows, as well as viewed rows to decide\n      //     // which part of code needs to be compiled\n      //     let cursorPosition: Position = this.getCursorPosition()\n      //     this.setTextContent(this._insertTextAtPosition('\\n', cursorPosition))\n\n      //     // Update the selection state to the new line\n      //     this.setSelection({\n      //       start: {\n      //         row: cursorPosition.row + 1,\n      //         column: 0\n      //       },\n      //       end: {\n      //         row: cursorPosition.row + 1,\n      //         column: 0\n      //       }\n      //     })\n\n      //   default:\n      //     break\n      // }\n\n      // this._process\n      // this.setTextContent(this._compileKeydown(evt, this.getCursorPosition()))\n      // let oldTextContent: string = this.getTextContent(),\n      //     newTextContent: string = this._compileKeydown(evt, this.getCursorPosition())\n\n      // if (newTextContent !== oldTextContent) {\n      // }\n    }\n  }, {\n    key: '_handleKeyup',\n    value: function _handleKeyup(evt /*: KeyboardEvent*/) {\n      // let textContent: string = this._compileTextContent()\n      if (Lighditor.util.getKeycode(evt) === Lighditor.util.keycode.ENTER) {\n        evt.preventDefault();\n        return;\n      }\n\n      // // TODO: update selection if arrow key is up\n      this._updateSelection();\n\n      // evt.preventDefault()\n      // // TODO: We may not need to update the whole editor text content\n      // // but only the section that is actually changed\n      // // this.saveSelection()\n      // if (Lighditor.util.isValidCharInput(evt)) {\n      //   // let textContent: string = this._compileTextContent()\n      //   this.setTextContent(this._compileTextContent())\n      // }\n\n      this.setTextContent(this._compileTextContent());\n      // // this._applySelection()\n    }\n\n    // _handlePaste (evt: KeyboardEvent) {\n    //   Lighditor.log('_handlePaste', evt)\n    // }\n\n  }, {\n    key: '_handleMouseup',\n    value: function _handleMouseup(evt /*: MouseEvent*/) {\n      this._updateSelection();\n    }\n\n    /***** Lifecycle *****/\n    // There are four major lifecycles for a set of content in Lighditor. Lighditor will process the content\n    // by chunks defined by user, so that the four phases can happen in parallel.\n    //\n    // Some keywords:\n    // chunk: a string chunk to be parsed/rendered as a whole, which will passing the following lifecycles. A chunk contains config\n    //        information, as well as the body of text content to be rendered\n    // set: a string set contains one or multiple chunks, and can be understood by parser to give highlights, autocompletes, etc\n    //\n    // Compile phase\n    // - Get the dirty HTML from browser after user interaction\n    // - Compile the HTML into chunks of formatted content strings, including all information needed for render\n    // - Passing the string chunks into rendering queue\n    // - Notify rendering queue if the previous string chunks is a complete set of content to parse\n    // - Notify rendering queue that compilation finishes and no more formatted string to render\n    //\n    // Queue phase\n    // - The content string can be stored as chunks for rendering early access\n    // - Some queue keywords for singalling. For example 'SET_COMPLETE' for a EOF set signal.\n    // - Some queue management, for example promote some chunks by priority for rendering management\n    //\n    // Render phase\n    // - Read from the rendering queue for formatted string chunks to renderer\n    // - Render the string chunk with default plain text parser on screen\n    // - The rendered result will be formatted HTML\n    //\n    // Parse phase\n    // - Parser will be required from comsumer of Lighditor or using the default one (plain text)\n    // - Parser is watching the renderer process. When it sees a signal for a set content in queue, it will start parsing\n    // - Whenever a parsed result is produced, it will be send to rendering queue in some proper priority\n\n\n    /**\n     * Called after text content is changed\n     */\n\n  }, {\n    key: 'onTextContentChange',\n    value: function onTextContentChange(newTextContent /*: string*/, oldTextContent /*: string*/) /*: void*/ {}\n\n    /**\n     * Called after selection is changed\n     */\n\n  }, {\n    key: 'onSelectionChange',\n    value: function onSelectionChange(newSelection /*: Selection*/, oldSelection /*: Selection*/) /*: void*/ {}\n\n    /***** Compile phase *****/\n\n  }, {\n    key: '_dfsTraverseNode',\n    value: function _dfsTraverseNode(callback /*: (node: Node, row: number, column: number) => ?boolean*/) /*: void*/ {\n      var nodeStack = [this.editorElement],\n          row /*: number*/ = -1,\n          column /*: number*/ = 0,\n          node /*: ?Node*/ = void 0;\n      // When there are <br> element in row, we need to add extra row\n      // extraRowCount: number = 0\n\n      while (node = nodeStack.pop()) {\n        // /** Fix for firefox */\n        // if (this._isBRElement(node)) {\n        //   extraRowCount++\n        //   row++\n        //   column = 0\n        // }\n        // /** Fix for firefox end */\n\n        if (this._isRowNode(node)) {\n          row = this._getRowIndex(node);\n          column = 0;\n        }\n\n        if (callback(node, row, column)) {\n          break;\n        }\n\n        if (node instanceof Text) {\n          column += node.length;\n        }\n\n        if (node.childNodes && node.childNodes.length) {\n          var childNodes = node.childNodes;\n          var childIndex /*: number*/ = childNodes.length;\n\n          while (childIndex--) {\n            nodeStack.push(childNodes[childIndex]);\n          }\n        }\n      }\n    }\n\n    /**\n     * Traverse the raw dirty HTML in editor with DFS, which makes sure\n     * we are traversing from the beginning to the end of lines\n     */\n\n  }, {\n    key: '_dfsTraverseRawNode',\n    value: function _dfsTraverseRawNode(callback /*: (node: Node) => ?boolean*/) /*: void*/ {\n      var nodeStack = [this.editorElement],\n          node /*: ?Node*/ = void 0;\n      // When there are <br> element in row, we need to add extra row\n      // extraRowCount: number = 0\n\n      while (node = nodeStack.pop()) {\n\n        if (callback(node)) {\n          break;\n        }\n\n        if (node.childNodes && node.childNodes.length) {\n          var childNodes = node.childNodes;\n          var childIndex /*: number*/ = childNodes.length;\n\n          while (childIndex--) {\n            nodeStack.push(childNodes[childIndex]);\n          }\n        }\n      }\n    }\n\n    /**\n     * Get the text from the actual contents, including new lines\n     *\n     * When hitting new line (enter key):\n     * 1. chrome/safari will clone the current row and move the rest of text to the new row.\n     * 2. firefox will keep the two piece of string in the same row and add a 'br' element\n     */\n\n  }, {\n    key: '_compileTextContent',\n    value: function _compileTextContent() /*: string*/ {\n      var _this2 = this;\n\n      var contents /*: string*/ = '';\n\n      this._dfsTraverseRawNode(function (node /*: Node*/) {\n        // console.log('Traverse node', node)\n\n        // if (this._isRowNode(node)) {\n        //   // Warn if current row has content already. By DFS we are guaranteed\n        //   // the row element is ran againast with first\n        //   if (typeof contents[row] !== 'undefined') {\n        //     Lighditor.warn('Row ' + row + ' has rendered')\n        //   }\n\n        //   // Make sure each row has a new line\n        //   contents[row] = []\n        // }\n\n        if (node instanceof Text) {\n          // let rowContent = contents[row]\n\n          // /** Error checks **/\n\n          // // Warn if we have empty positions\n          // if (column > 0 && typeof rowContent[column - 1] === 'undefined') {\n          //   console.warn('Row ' + row + ' has unassigned character at column ' + (column - 1))\n          //   // Need to make up all unassigned position with space key\n          //   let col = column\n          //   while (typeof rowContent[col - 1] === 'undefined') {\n          //     rowContent[col - 1] = ' '\n          //     col--\n          //   }\n\n          //   // TODO: Should we return true and stop traversal?\n          // }\n\n          // // Warn if we already have character at column position\n          // if (rowContent.length > column) {\n          //   console.error('Row ' + row + ' has exist character at column ' + column)\n          //   return true\n          // }\n\n          // /** Error checks end **/\n\n          // // Copy nodeText to row content\n          // let nodeText = node.textContent\n          // for (let i = column; i < nodeText.length; i++) {\n          //   rowContent[i] = nodeText[i - column]\n          // }\n\n          contents += node.textContent;\n        }\n\n        if (_this2._isNewLineElement(node)) {\n          contents += '\\n';\n        }\n      });\n\n      // console.log('content: ', contents)\n      // console.log('------------------ Traverse node finished ------------------')\n\n      // Try some crazy regexp way\n      // let tempElement: HTMLElement = document.createElement('div')\n\n      // tempElement.innerHTML = this.editorElement.innerHTML\n      //   .replace(/<(div|p|br)[^<]*?>/g, '&lt;br /&gt;')\n      //   .replace(/<([(i|a|b|u)^>]+)>(.*?)<\\/\\1>/gim,\n      //     function(v) { return '' + window.escape(v) + ''; })\n\n      // contents = tempElement.textContent\n\n      // function extractTextWithWhitespace( elems ) {\n      //     var ret = \"\", elem;\n\n      //     for ( var i = 0; elems[i]; i++ ) {\n      //         elem = elems[i];\n\n      //         // Get the text from text nodes and CDATA nodes\n      //         if ( elem.nodeType === 3 || elem.nodeType === 4 ) {\n      //             ret += elem.nodeValue + \"\\n\";\n\n      //         // Traverse everything else, except comment nodes\n      //         } else if ( elem.nodeType !== 8 ) {\n      //             ret += extractTextWithWhitespace( elem.childNodes );\n      //         }\n      //     }\n\n      //     return ret;\n      // }\n\n      // contents = extractTextWithWhitespace([this.editorElement])\n\n      // contents = this.editorElement.innerText\n\n      // dirtyHTML = this.editorElement.innerHTML\n\n      // contents = this.editorElement.innerHTML\n      //   .replace(/\\<br/g, '\\n')\n      //   .replace(/\\<[^>]*\\>/g, '')\n      return contents;\n    }\n\n    /**\n     * compile happens when keydown. Manually translate the keyboard input\n     * to actual text content\n     */\n\n  }, {\n    key: '_compileKeydown',\n    value: function _compileKeydown(event /*: KeyboardEvent*/, cursorPosition /*: Position*/) /*: string*/ {\n      Lighditor.log('compile', arguments);\n\n      switch (Lighditor.util.getKeycode(event)) {\n        case Lighditor.util.keycode.ENTER:\n          event.preventDefault();\n\n          // When hit enter key, a new line will generated and the rest of the current\n          // line will be moved to the new line\n          // let newLineFragment = document.createDocumentFragment()\n\n          // TODO: use view start rows and viable rows, as well as viewed rows to decide\n          // which part of code needs to be compiled\n          return this._insertTextAtPosition('\\n', cursorPosition);\n\n        default:\n          return this.getTextContent();\n      }\n    }\n  }, {\n    key: '_insertTextAtPosition',\n    value: function _insertTextAtPosition(text /*: string*/, position /*: Position*/) /*: string*/ {\n      var positionCharIndex = this._getCharIndexByPosition(position),\n          prevTextContent /*: string*/ = this.getTextContent().slice(0, positionCharIndex),\n          afterTextContent /*: string*/ = this.getTextContent().slice(positionCharIndex);\n\n      return prevTextContent + text + afterTextContent;\n    }\n  }, {\n    key: '_removeTextAtPosition',\n    value: function _removeTextAtPosition(position /*: Position*/) /*: string*/ {\n      var direction /*: ?string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'left';\n\n      var positionCharIndex = this._getCharIndexByPosition(position),\n          prevTextContent /*: string*/ = direction === 'left' ? this.getTextContent().slice(0, positionCharIndex - 1) : this.getTextContent().slice(0, positionCharIndex),\n          afterTextContent /*: string*/ = direction === 'left' ? this.getTextContent().slice(positionCharIndex) : this.getTextContent().slice(positionCharIndex + 1);\n\n      return prevTextContent + afterTextContent;\n    }\n\n    // _compileTextContent (): string {\n    //   let contents: string = ''\n\n    //   this._dfsTraverseNode((node: Node, row: number, column: number) => {\n    //     console.log('Traverse node', node, row, column)\n\n    //     if (this._isRowNode(node) || this._isBRElement(node)) {\n    //       // Warn if current row has content already. By DFS we are guaranteed\n    //       // the row element is ran againast with first\n    //       if (typeof contents[row] !== 'undefined') {\n    //         Lighditor.warn('Row ' + row + ' has rendered')\n    //       }\n\n    //       // Make sure each row has a new line\n    //       contents[row] = []\n    //     }\n\n    //     if (node instanceof Text) {\n    //       let rowContent = contents[row]\n\n    //       /** Error checks **/\n\n    //       // Warn if we have empty positions\n    //       if (column > 0 && typeof rowContent[column - 1] === 'undefined') {\n    //         console.warn('Row ' + row + ' has unassigned character at column ' + (column - 1))\n    //         // Need to make up all unassigned position with space key\n    //         let col = column\n    //         while (typeof rowContent[col - 1] === 'undefined') {\n    //           rowContent[col - 1] = ' '\n    //           col--\n    //         }\n\n    //         // TODO: Should we return true and stop traversal?\n    //       }\n\n    //       // Warn if we already have character at column position\n    //       if (rowContent.length > column) {\n    //         console.error('Row ' + row + ' has exist character at column ' + column)\n    //         return true\n    //       }\n\n    //       /** Error checks end **/\n\n    //       // Copy nodeText to row content\n    //       let nodeText = node.textContent\n    //       for (let i = column; i < nodeText.length; i++) {\n    //         rowContent[i] = nodeText[i - column]\n    //       }\n    //     }\n    //   })\n\n    //   console.log('content: ', contents.map((rowArray) => { return rowArray.join('\\n') }))\n    //   console.log('------------------ Traverse node finished ------------------')\n\n    //   return contents.map((rowArray) => { return rowArray.join('') }).join('\\n')\n    // }\n\n  }, {\n    key: '_getCharIndexByPosition',\n    value: function _getCharIndexByPosition(position /*: Position*/) /*: number*/ {\n      var row = position.row,\n          charCount = 0;\n\n      for (; --row >= 0;) {\n        charCount += this._getTextContentByRow(row).length + 1;\n      }\n\n      return charCount + position.column;\n    }\n  }, {\n    key: '_getTextContentByRow',\n    value: function _getTextContentByRow(row /*: number*/) /*: string*/ {\n      var rowNodes = this.editorElement.childNodes,\n          rowNode /*: ?Node*/ = rowNodes[row];\n\n      if (rowNode) {\n        return rowNode.textContent;\n      } else {\n        Lighditor.warn('Try to get row that not exist', row);\n        return '';\n      }\n    }\n\n    /**\n     * Keep goes up and get the row node from current node.\n     * Also calculate the row for given node\n     */\n\n  }, {\n    key: '_getRowInfo',\n    value: function _getRowInfo(node /*: Node*/) /*: ?RowInfo*/ {\n      var currentNode = node;\n\n      while (currentNode && currentNode !== this.editorElement) {\n        if (this._isRowNode(currentNode)) {\n          // Found nearest row container\n          var rowCount = 0;\n          var n = currentNode;\n          for (; n = n.previousSibling; rowCount++) {}\n\n          return {\n            container: currentNode,\n            row: rowCount\n          };\n        }\n\n        currentNode = currentNode.parentElement;\n      }\n\n      return null;\n    }\n\n    /**\n     * Get the row index of given node\n     */\n\n  }, {\n    key: '_getRowIndex',\n    value: function _getRowIndex(node /*: Node*/) /*: number*/ {\n      var rowNode /*: ?RowInfo*/ = this._getRowInfo(node);\n      if (!rowNode) {\n        return -1;\n      } else {\n        return rowNode.row;\n      }\n    }\n  }, {\n    key: '_getRowElementByIndex',\n    value: function _getRowElementByIndex(row /*: number*/) /*: ?HTMLElement | ?Text*/ {\n      var node = this.editorElement.childNodes[row];\n      if (node instanceof HTMLElement || node instanceof Text) {\n        return node;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Return true if the given node should be represented as a single row\n     */\n\n  }, {\n    key: '_isRowNode',\n    value: function _isRowNode(node /*: Node*/) /*: boolean*/ {\n      // return node.parentElement === this.editorElement\n      if (node instanceof HTMLElement) {\n        return node.dataset && node.dataset['lighditorType'] === 'row';\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: '_isBRElement',\n    value: function _isBRElement(node /*: Node*/) /*: boolean*/ {\n      // TODO: FLOW cannot reslove HTMLBRElement!\n      // return node instanceof HTMLBRElement\n      return node.nodeName === 'BR';\n    }\n  }, {\n    key: '_isNewLineElement',\n    value: function _isNewLineElement(node /*: Node*/) /*: boolean*/ {\n      // return this._isBRElement(node) || this._isRowNode(node)\n      // return this._isRowNode(node)\n      if (node instanceof HTMLElement) {\n        return node.dataset && node.dataset['lighditorType'] === 'newline';\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * A new line row node is a node that has only <br>s\n     */\n    // _isNewLineRow (node: Node): boolean{\n    //   let hasOnlyBrNode = false\n\n    //   if (node.childNodes && node.childNodes.length) {\n\n    //   }\n\n    //   if (node.textContent === '' && )\n    // }\n\n\n    /***** Queue phase *****/\n\n    /***** Render phase *****/\n\n    /***** Parse phase *****/\n\n    /***** Editor utils *****/\n\n    /***** Cursor and selection *****/\n\n  }, {\n    key: '_getSelectionNodePosition',\n    value: function _getSelectionNodePosition(positionType /*: PositionTypeEnum*/) /*: ?Position*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var currentSelection = window.getSelection();\n        var node /*: HTMLElement | Text*/ = void 0;\n\n        switch (positionType) {\n          case 'START':\n            node = currentSelection.anchorNode;\n            // if (!(node instanceof Text)) {\n            //   node = node.childNodes[currentSelection.anchorOffset]\n            // }\n            break;\n\n          case 'END':\n            node = currentSelection.focusNode;\n            // if (!(node instanceof Text)) {\n            //   node = node.childNodes[currentSelection.focusOffset]\n            // }\n            break;\n\n          default:\n            node = currentSelection.focusNode;\n          // if (!(node instanceof Text)) {\n          //   node = node.childNodes[currentSelection.focusOffset]\n          // }\n        }\n\n        if (!node) {\n          return null;\n        }\n\n        var rowInfo /*: ?RowInfo*/ = this._getRowInfo(node);\n\n        if (!rowInfo) {\n          return null;\n        }\n\n        var rangeBeforeNodeInRow = document.createRange();\n        rangeBeforeNodeInRow.selectNodeContents(rowInfo.container);\n        rangeBeforeNodeInRow.setEnd(node, 0);\n\n        return {\n          row: rowInfo.row,\n          column: rangeBeforeNodeInRow.toString().length\n        };\n      } else {\n        // TODO: add support for old IE\n        return null;\n      }\n    }\n\n    /**\n     * Get the current selection's start position\n     */\n\n  }, {\n    key: '_getSelectionStartNodePosition',\n    value: function _getSelectionStartNodePosition() /*: ?Position*/ {\n      return this._getSelectionNodePosition('START');\n    }\n\n    /**\n     * Get the current selection's end position\n     */\n\n  }, {\n    key: '_getSelectionEndNodePosition',\n    value: function _getSelectionEndNodePosition() /*: ?Position*/ {\n      return this._getSelectionNodePosition('END');\n    }\n\n    /**\n     * Return true if selection start is after end, as range always is from\n     * start to end\n     */\n\n  }, {\n    key: '_isRangeReversed',\n    value: function _isRangeReversed(selection /*: Selection*/) /*: boolean*/ {\n      return selection.start.row > selection.end.row || selection.start.column > selection.end.column;\n    }\n  }, {\n    key: '_getTextContentByOffset',\n    value: function _getTextContentByOffset(container /*: Node*/, offset /*: number*/) /*: string*/ {\n      var textContent /*: string*/ = '';\n\n      if (!(container instanceof Text)) {\n        for (var i = 0; i < offset; i++) {\n          textContent += container.childNodes[i].textContent;\n        }\n      } else {\n        textContent = container.toString().slice(0, offset);\n      }\n\n      return textContent;\n    }\n\n    /**\n     * Update the selection state from user interaction\n     */\n\n  }, {\n    key: '_updateSelection',\n    value: function _updateSelection() /*: void*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var currentSelection = window.getSelection();\n\n        if (!currentSelection.focusNode || !currentSelection.anchorNode) {\n          return;\n        }\n\n        var selectionStartPosition /*: ?Position*/ = this._getSelectionStartNodePosition(),\n            selectionEndPosition /*: ?Position*/ = this._getSelectionEndNodePosition();\n\n        if (selectionStartPosition && selectionEndPosition) {\n\n          var rangeStartColumn /*: number*/ = void 0,\n              rangeEndColumn /*: number*/ = void 0,\n              range = currentSelection.getRangeAt(0);\n\n          // Find the text content length for range start and end offset\n          var rangeStartOffset /*: number*/ = this._getTextContentByOffset(range.startContainer, range.startOffset).length,\n              rangeEndOffset /*: number*/ = this._getTextContentByOffset(range.endContainer, range.endOffset).length;\n\n          if (this._isRangeReversed({\n            start: selectionStartPosition,\n            end: selectionEndPosition\n          })) {\n            rangeStartColumn = rangeEndOffset;\n            rangeEndColumn = rangeStartOffset;\n          } else {\n            rangeStartColumn = rangeStartOffset;\n            rangeEndColumn = rangeEndOffset;\n          }\n\n          this.setSelection({\n            start: {\n              row: selectionStartPosition.row,\n              column: selectionStartPosition.column + rangeStartColumn\n            },\n            end: {\n              row: selectionEndPosition.row,\n              column: selectionEndPosition.column + rangeEndColumn\n            }\n          });\n        }\n      } else {\n        // TODO: add support for old IE\n      }\n    }\n\n    // Restore the saved selection and cursor position\n    // REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n\n  }, {\n    key: '_applySelection',\n    value: function _applySelection() /*: void*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var getRangeSide = function getRangeSide(node /*: Node*/, nodeStartColumn /*: number*/, sideColumn /*: number*/) {\n          var side = null;\n          var nodeCharLength /*: number*/ = 0;\n          // if (node instanceof Text) {\n          if (node instanceof Text) {\n            nodeCharLength = node.length;\n          }\n\n          var nodeEndColumn = nodeStartColumn + nodeCharLength;\n\n          if (sideColumn >= nodeStartColumn && sideColumn <= nodeEndColumn) {\n            // Found the text node where side column inside node\n            side = {\n              node: node,\n              offset: sideColumn - nodeStartColumn\n            };\n          }\n          // }\n\n          return side;\n        };\n\n        var _selection = this.editorState.selection;\n\n        if (!_selection) {\n          return;\n        }\n\n        var range = document.createRange(),\n            rangeStart /*: Position*/ = void 0,\n            rangeEnd /*: Position*/ = void 0;\n\n        if (this._isRangeReversed(_selection)) {\n          rangeStart = _selection.end;\n          rangeEnd = _selection.start;\n        } else {\n          rangeStart = _selection.start;\n          rangeEnd = _selection.end;\n        }\n\n        var rangeStartRowElement = this._getRowElementByIndex(rangeStart.row),\n            rangeEndRowElement = this._getRowElementByIndex(rangeEnd.row),\n            side1 = void 0,\n            side2 = void 0;\n\n        if (!rangeStartRowElement || !rangeEndRowElement) {\n          return;\n        }\n\n        // Set the range to the current cursor position to start with\n        range.setStart(rangeStartRowElement, 0);\n        range.collapse(true);\n\n        this._dfsTraverseNode(function (node /*: Node*/, row /*: number*/, column /*: number*/) {\n          if (node.childNodes.length === 0) {\n\n            if (!side1 && row === rangeStart.row) {\n              side1 = getRangeSide(node, column, rangeStart.column);\n              if (side1) {\n                range.setStart(side1.node, side1.offset);\n              }\n            }\n\n            if (!side2 && row === rangeEnd.row) {\n              side2 = getRangeSide(node, column, rangeEnd.column);\n              if (side2) {\n                range.setEnd(side2.node, side2.offset);\n              }\n            }\n\n            if (side1 && side2) {\n              return true;\n            }\n          }\n        });\n\n        var sel = window.getSelection();\n        sel.removeAllRanges();\n        sel.addRange(range);\n      }\n    }\n\n    /***** Utils *****/\n\n  }], [{\n    key: 'create',\n    value: function create(element /*: HTMLElement*/, config /*: ?LighditorConfig*/) {\n      var actualConfig /*: LighditorConfig*/ = {\n        initTextContent: '',\n        viewStartRow: 0,\n        viewableRows: Infinity\n        // shouldRender: null\n\n\n        // make sure defaults in config\n      };if (typeof config !== 'undefined') {\n        for (var key in config) {\n          if (config.hasOwnProperty(key)) {\n            actualConfig[key] = config[key];\n          }\n        }\n      }\n\n      return new Lighditor(element, actualConfig);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy(editor /*: Lighditor*/) /*: boolean*/ {\n      if (editor instanceof Lighditor) {\n        return editor._destroy();\n      } else {\n        Lighditor.warn('Try desgroy non-Lighditor: ', editor);\n        return true;\n      }\n    }\n  }, {\n    key: 'enableLog',\n    value: function enableLog() {\n      localStorage.setItem('lighditor.enableLog', 'true');\n    }\n  }, {\n    key: 'disableLog',\n    value: function disableLog() {\n      localStorage.setItem('lighditor.enableLog', 'false');\n    }\n  }, {\n    key: 'log',\n    value: function log() {\n      if (localStorage.getItem('lighditor.enableLog') === 'true') {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        console.log.apply(null, args);\n      }\n    }\n  }, {\n    key: 'warn',\n    value: function warn() {\n      if (localStorage.getItem('lighditor.enableLog') === 'true') {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        console.warn.apply(null, args);\n      }\n    }\n  }, {\n    key: 'enableDebug',\n    value: function enableDebug() {\n      localStorage.setItem('lighditor.enableDebug', 'true');\n    }\n  }, {\n    key: 'disableDebug',\n    value: function disableDebug() {\n      localStorage.setItem('lighditor.enableDebug', 'false');\n    }\n  }, {\n    key: 'debug',\n    value: function debug(callback /*: () => mixed*/) {\n      if (localStorage.getItem('lighditor.enableLog') === 'true') {\n        callback();\n      }\n    }\n  }, {\n    key: 'util',\n    get: function get() {\n\n      return {\n        keycode: {\n          ENTER: 13,\n          BACKSPACE: 8\n        },\n\n        getKeycode: function getKeycode(event /*: KeyboardEvent*/) /*: number*/ {\n          var keyCode = event.which;\n\n          // getting the key code from event\n          if (null === keyCode) {\n            keyCode = event.charCode !== null ? event.charCode : event.keyCode;\n          }\n\n          return keyCode;\n        },\n\n        /**\n         * Return true if the given key is a valid character input\n         * Ref https://css-tricks.com/snippets/javascript/javascript-keycodes/\n         */\n        isValidCharInput: function isValidCharInput(event /*: KeyboardEvent*/) /*: boolean*/ {\n          var key /*: number*/ = Lighditor.util.getKeycode(event);\n\n          return 48 <= key && key <= 57 || // Numbers\n          65 <= key && key <= 90 // a-z\n          || 96 <= key && key <= 111 // Keypad\n          || 186 <= key && key <= 192 // period\n          || 219 <= key && key <= 222; // brakets\n        }\n      };\n    }\n  }]);\n\n  return Lighditor;\n}();\n\n// Lighditor.util = {\n//   keycode: {\n//     ENTER: 13\n//   },\n\n//   getKeycode: (event: KeyboardEvent): number => {\n//     let keyCode = event.which\n\n//     // getting the key code from event\n//     if (null === keyCode) {\n//         keyCode = event.charCode !== null ? event.charCode : event.keyCode\n//     }\n\n//     return keyCode\n//   },\n\n//   *\n//    * Return true if the given key is a valid character input\n//    * Ref https://css-tricks.com/snippets/javascript/javascript-keycodes/\n\n//   isValidCharInput: (event: KeyboardEvent): boolean => {\n//     let key: number = Lighditor.util.getKeycode(event)\n\n//     return (48 <= key && key <= 57) // Numbers\n//       || (65 <= key && key <= 90) // a-z\n//       || (96 <= key && key <= 111) // Keypad\n//       || (186 <= key && key <= 192) // period\n//       || (219 <= key && key <= 222) // brakets\n//   }\n\n// }\n\nwindow.Lighditor = Lighditor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lighditor.js\n// module id = 1\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./lighditor.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./lighditor.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./lighditor.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lighditor.scss\n// module id = 2\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".lighditorElement {\\n  height: 200px;\\n  outline: none;\\n  border: 1px solid black;\\n  overflow: auto; }\\n  .lighditorElement .lighditorRow {\\n    font-family: courier;\\n    height: 14px;\\n    line-height: 14px; }\\n\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/lighditor.scss\n// module id = 3\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader/lib/css-base.js\n// module id = 4\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/addStyles.js\n// module id = 5\n// module chunks = 0","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/urls.js\n// module id = 6\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACp1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}