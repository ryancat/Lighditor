{"version":3,"file":"lighditor.js","sources":["webpack:///webpack/bootstrap 7c5b5e7d22f9f0f0412c","webpack:///./src/lighditor.js","webpack:///./src/lighditor.scss?d0ec","webpack:///./src/lighditor.scss","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7c5b5e7d22f9f0f0412c","'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n// Web editor should support\n// 1. Basic type in editor\n// 2. Get/Set cursor position\n// 3. Get/Set selection\n// 4. Get/Set text content\n// 5.\n//\n\nvar _lighditor = require('./lighditor.scss');\n\nvar _lighditor2 = _interopRequireDefault(_lighditor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*:: type Position = {\n  row: number,\n  column: number\n}*/\n/*:: type Selection = {\n  start: Position,\n  end: Position\n}*/\n/*:: type Range = {\n  start: Position,\n  end: Position\n}*/\n/*:: type LighditorConfig = {\n  initTextContent: string\n}*/\n/*:: type LighditorProps = {\n  element: HTMLElement,\n  config: ?LighditorConfig\n}*/\n/*:: type LighditorState = {\n  textContent: string,\n  cursorPosition: Position,\n  selection: {\n    start: Position,\n    end: Position\n  }\n}*/\n/*:: type RowInfo = {\n  element: HTMLElement | Text,\n  row: number\n}*/\n\n\nvar EditorClass = {\n  CONTAINER: 'lighditorContainer',\n  ELEMENT: 'lighditorRawElement',\n  EDITOR_ELEMENT: 'lighditorElement',\n  EDITOR_ROW: 'lighditorRow'\n};\n\nvar positionTypeEnum = {\n  START: 'start',\n  END: 'end'\n};\n\n// Feature detection\n/*:: type PositionTypeEnum = $Keys<typeof positionTypeEnum>*/\nvar featureGetSelection = !!window.getSelection;\nvar featureCreateRange = !!document.createRange;\n\nvar lighditorUtil = {\n\n  throttle: function throttle(callback /*: () => mixed*/) {\n    var interval /*: number*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    var lastCalledTimestamp /*: ?number*/ = void 0,\n        timeoutId = void 0;\n\n    function refreshTimeout() {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(function () {\n        lastCalledTimestamp = null;\n      }, interval);\n    }\n\n    function throttled() {\n      if (!lastCalledTimestamp) {\n        lastCalledTimestamp = Date.now();\n        refreshTimeout();\n        callback();\n      }\n    }\n\n    return throttled;\n  }\n\n};\n\nvar Lighditor = function () {\n  function Lighditor(props /*: LighditorProps*/) {\n    _classCallCheck(this, Lighditor);\n\n    this.element = props.element;\n    this.editorConfig = props.config || {\n      initTextContent: ''\n\n      // this.resetRender()\n      // this.build()\n      // this.listen()\n      // @attachListeners()\n      //\n\n      // Decorate prototype\n      // this.render = lighditorUtil.debounce(this.render.bind(this))\n    };\n  }\n\n  _createClass(Lighditor, [{\n    key: 'resetRender',\n    value: function resetRender() /*: void*/ {\n      this.setEditorState({\n        textContent: '',\n        cursorPosition: { row: 0, column: 0 },\n        selection: {\n          start: { row: 0, column: 0 },\n          end: { row: 0, column: 0 }\n        }\n      });\n    }\n  }, {\n    key: 'build',\n    value: function build(config /*: ?LighditorConfig*/) {\n      // Error checks\n      if (typeof this.element === 'undefined') {\n        throw new Error('Missing element for editor');\n      }\n\n      var elementParent = this.element.parentElement;\n      if (!elementParent) {\n        throw new Error('Element set to html document is not supported');\n      }\n\n      // Update config\n      if (typeof config !== 'undefined') {\n        for (var key in config) {\n          if (config.hasOwnProperty(key)) {\n            this.editorConfig[key] = config[key];\n          }\n        }\n      }\n\n      var wrapperElement /*: HTMLDivElement*/ = document.createElement('div');\n      wrapperElement.classList.add(EditorClass.CONTAINER);\n\n      // Replace with input element\n      elementParent.replaceChild(wrapperElement, this.element);\n      this.element.classList.add(EditorClass.ELEMENT);\n\n      // Make sure the original element is not shown\n      this.element.style.display = 'none';\n      wrapperElement.appendChild(this.element);\n\n      // Create editor\n      this.editorElement = document.createElement('div');\n      this.editorElement.classList.add(EditorClass.EDITOR_ELEMENT);\n\n      // Make editor element editable\n      this.editorElement.setAttribute('contenteditable', 'true');\n      wrapperElement.appendChild(this.editorElement);\n\n      // Reset editor state\n      this.resetRender();\n\n      // Attach listeners\n      this.listen();\n\n      // Setup placeholder or init text\n      this.setTextContent(this.editorConfig.initTextContent || '');\n    }\n  }, {\n    key: 'listen',\n    value: function listen() /*: void*/ {\n      this.editorElement.addEventListener('keydown', this.handleKeydown.bind(this));\n      this.editorElement.addEventListener('keyup', this.handleKeyup.bind(this));\n    }\n\n    /**\n     * Render the editor element inner html based on current editor state\n     */\n\n  }, {\n    key: 'render',\n    value: function render() /*: void*/ {\n      // Render the text content\n      var textContent /*: string*/ = this.editorState.textContent;\n      var textContentRows /*: string[]*/ = textContent.split('\\n');\n      var html /*: string*/ = '';\n\n      textContentRows.forEach(function (textContentRow) {\n        html += '<div class=\"' + EditorClass.EDITOR_ROW + '\" data-lighditor-type=\"row\">' + textContentRow + '</div>';\n      });\n\n      this.editorElement.innerHTML = html;\n\n      // Render the selection/cursor\n      this.restoreSelection();\n    }\n\n    /***** Event handlers *****/\n\n  }, {\n    key: 'handleKeydown',\n    value: function handleKeydown(evt /*: KeyboardEvent*/) {}\n  }, {\n    key: 'handleKeyup',\n    value: function handleKeyup(evt /*: KeyboardEvent*/) {\n      var textContent /*: string*/ = this._getInputText();\n\n      // TODO: update selection if arrow key is up\n      this.updateSelection();\n\n      // TODO: We may not need to update the whole editor text content\n      // but only the section that is actually changed\n      // this.saveSelection()\n      this.setTextContent(textContent);\n      // this.restoreSelection()\n    }\n  }, {\n    key: 'handleMouseup',\n    value: function handleMouseup(evt /*: MouseEvent*/) {\n      this.updateSelection();\n    }\n\n    /***** Lifecycle events *****/\n    /**\n     * Called after text content is changed\n     */\n\n  }, {\n    key: 'onTextContentChange',\n    value: function onTextContentChange(newTextContent /*: string*/, oldTextContent /*: string*/) /*: void*/ {}\n\n    /**\n     * Called after selection is changed\n     */\n\n  }, {\n    key: 'onSelectionChange',\n    value: function onSelectionChange(newSelection /*: Selection*/, oldSelection /*: Selection*/) /*: void*/ {}\n\n    /***** Setters *****/\n\n  }, {\n    key: 'setEditorState',\n    value: function setEditorState(editorState /*: LighditorState*/) /*: void*/ {\n      var _this = this;\n\n      console.log('calling setEditorState: ', editorState);\n\n      this.editorState = _extends({}, editorState);\n\n      // When we set editor state, we need to re-render the content\n      // based on given parser\n      // TODO: Considering use virtual dom to render editor\n      setTimeout(function () {\n        _this.render();\n      });\n    }\n  }, {\n    key: 'setTextContent',\n    value: function setTextContent(textContent /*: string*/) /*: void*/ {\n      var oldTextContent = this.editorState.textContent;\n\n      this.setEditorState(_extends({}, this.editorState, {\n        textContent: textContent\n      }));\n\n      this.onTextContentChange(textContent, oldTextContent);\n    }\n  }, {\n    key: 'setSelection',\n    value: function setSelection(selection /*: Selection*/) /*: void*/ {\n      var oldSelection = this.editorState.selection;\n\n      this.setEditorState(_extends({}, this.editorState, {\n        selection: selection\n      }));\n\n      this.onSelectionChange(selection, oldSelection);\n    }\n\n    /***** Text content *****/\n\n  }, {\n    key: '_dfsTraverseNode',\n    value: function _dfsTraverseNode(callback /*: (node: Node, row: number, column: number) => ?boolean*/) /*: void*/ {\n      var nodeStack = [this.editorElement];\n      var row /*: number*/ = 0;\n      var column /*: number*/ = 0;\n      var node /*: ?Node*/ = void 0;\n\n      while (node = nodeStack.pop()) {\n        if (this.isRowElement(node)) {\n          row = this.getRowIndex(node);\n          column = 0;\n        }\n\n        if (callback(node, row, column)) {\n          break;\n        }\n\n        if (node instanceof Text) {\n          column += node.length;\n        }\n\n        if (node.childNodes) {\n          var childNodes = node.childNodes;\n          var childIndex /*: number*/ = childNodes.length;\n\n          while (childIndex--) {\n            nodeStack.push(childNodes[childIndex]);\n          }\n        }\n      }\n    }\n\n    /**\n     * Get the text from the actual contents, including new lines\n     */\n\n  }, {\n    key: '_getInputText',\n    value: function _getInputText() /*: string*/ {\n      var _this2 = this;\n\n      var contents /*: Array<string[]>*/ = [];\n      // let lastRowElement: Node = this.getRowElementByIndex(this.editorElement.childNodes.length - 1)\n\n      this._dfsTraverseNode(function (node /*: Node*/, row /*: number*/, column /*: number*/) {\n        if (_this2.isRowElement(node)) {\n          // Warn if current row has content already. By DFS we are guaranteed\n          // the row element is ran againast with first\n          if (typeof contents[row] !== 'undefined') {\n            console.warn('Row ' + row + ' has rendered');\n          }\n\n          // Make sure each row has a new line\n          contents[row] = [];\n        }\n\n        if (node instanceof Text) {\n          var rowContent = contents[row];\n\n          // Warn if we have empty positions\n          if (column > 0 && typeof rowContent[column - 1] === 'undefined') {\n            console.warn('Row ' + row + ' has unassigned character at column ' + (column - 1));\n            // Need to make up all unassigned position with space key\n            var col = column;\n            while (typeof rowContent[col - 1] === 'undefined') {\n              rowContent[col - 1] = ' ';\n              col--;\n            }\n\n            // TODO: Should we return true and stop traversal?\n          }\n\n          // Warn if we already have character at column position\n          if (rowContent.length > column) {\n            console.error('Row ' + row + ' has exist character at column ' + column);\n            return true;\n          }\n\n          // Copy nodeText to row content\n          var nodeText = node.textContent;\n          for (var i = column; i < nodeText.length; i++) {\n            rowContent[i] = nodeText[i - column];\n          }\n        }\n      });\n\n      return contents.map(function (rowArray) {\n        return rowArray.join('');\n      }).join('\\n');\n    }\n  }, {\n    key: 'getRowIndex',\n    value: function getRowIndex(node /*: Node*/) /*: number*/ {\n      var rowNode /*: ?RowInfo*/ = this._getParentRowNode(node);\n      if (!rowNode) {\n        return -1;\n      } else {\n        return rowNode.row;\n      }\n    }\n  }, {\n    key: 'getRowElementByIndex',\n    value: function getRowElementByIndex(row /*: number*/) /*: ?HTMLElement | ?Text*/ {\n      var node = this.editorElement.childNodes[row];\n      if (node instanceof HTMLElement || node instanceof Text) {\n        return node;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'isRowElement',\n    value: function isRowElement(node /*: Node*/) /*: boolean*/ {\n      return node.parentElement === this.editorElement;\n    }\n\n    /***** Cursor and selection *****/\n\n  }, {\n    key: 'getSelection',\n    value: function getSelection() /*: Selection*/ {\n      return this.editorState.selection;\n    }\n\n    /**\n     * Recursively goes up and get the row node from current node\n     */\n\n  }, {\n    key: '_getParentRowNode',\n    value: function _getParentRowNode(node /*: Node*/) /*: ?RowInfo*/ {\n      var runningNode = node;\n\n      while (runningNode && runningNode !== this.editorElement) {\n        if ((runningNode instanceof HTMLElement || runningNode instanceof Text) && runningNode.parentElement === this.editorElement) {\n          var rowCount = 0;\n          var n = runningNode;\n          for (; n = n.previousSibling; rowCount++) {}\n\n          return {\n            element: runningNode,\n            row: rowCount\n          };\n        }\n\n        runningNode = runningNode.parentElement;\n      }\n\n      return null;\n    }\n  }, {\n    key: '_getSelectionNodePosition',\n    value: function _getSelectionNodePosition(positionType /*: PositionTypeEnum*/) /*: ?Position*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var currentSelection = window.getSelection();\n        var node /*: HTMLElement | Text*/ = void 0;\n\n        switch (positionType) {\n          case 'START':\n            node = currentSelection.anchorNode;\n            break;\n\n          case 'END':\n            node = currentSelection.focusNode;\n            break;\n\n          default:\n            node = currentSelection.focusNode;\n        }\n\n        if (!node) {\n          return null;\n        }\n\n        var rowInfo /*: ?RowInfo*/ = this._getParentRowNode(node);\n\n        if (!rowInfo) {\n          return null;\n        }\n\n        var rangeBeforeNodeInRow = document.createRange();\n        rangeBeforeNodeInRow.selectNodeContents(rowInfo.element);\n        rangeBeforeNodeInRow.setEnd(node, 0);\n\n        return {\n          row: rowInfo.row,\n          column: rangeBeforeNodeInRow.toString().length\n        };\n      } else {\n        // TODO: add support for old IE\n        return null;\n      }\n    }\n\n    /**\n     * Get the current selection's start position\n     */\n\n  }, {\n    key: '_getSelectionStartNodePosition',\n    value: function _getSelectionStartNodePosition() /*: ?Position*/ {\n      return this._getSelectionNodePosition('START');\n    }\n\n    /**\n     * Get the current selection's end position\n     */\n\n  }, {\n    key: '_getSelectionEndNodePosition',\n    value: function _getSelectionEndNodePosition() /*: ?Position*/ {\n      return this._getSelectionNodePosition('END');\n    }\n\n    /**\n     * Return true if selection start is after end, as range always is from\n     * start to end\n     */\n\n  }, {\n    key: '_isRangeReversed',\n    value: function _isRangeReversed(selection /*: Selection*/) /*: boolean*/ {\n      return selection.start.row > selection.end.row || selection.start.column > selection.end.column;\n    }\n\n    /**\n     * Update the selection state from user interaction\n     */\n\n  }, {\n    key: 'updateSelection',\n    value: function updateSelection() /*: void*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var currentSelection = window.getSelection();\n\n        if (!currentSelection.focusNode || !currentSelection.anchorNode) {\n          return;\n        }\n\n        var selectionStartPosition /*: ?Position*/ = this._getSelectionStartNodePosition(),\n            selectionEndPosition /*: ?Position*/ = this._getSelectionEndNodePosition();\n\n        if (selectionStartPosition && selectionEndPosition) {\n\n          var rangeStart /*: Position*/ = void 0,\n              rangeEnd /*: Position*/ = void 0,\n              range = currentSelection.getRangeAt(0);\n\n          if (this._isRangeReversed({\n            start: selectionStartPosition,\n            end: selectionEndPosition\n          })) {\n            rangeStart = range.endOffset;\n            rangeEnd = range.startOffset;\n          } else {\n            rangeStart = range.startOffset;\n            rangeEnd = range.endOffset;\n          }\n\n          this.setSelection({\n            start: {\n              row: selectionStartPosition.row,\n              column: selectionStartPosition.column + rangeStart\n            },\n            end: {\n              row: selectionEndPosition.row,\n              column: selectionEndPosition.column + rangeEnd\n            }\n          });\n        }\n      } else {\n        // TODO: add support for old IE\n      }\n    }\n\n    // Restore the saved selection and cursor position\n    // REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n\n  }, {\n    key: 'restoreSelection',\n    value: function restoreSelection() /*: void*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var getRangeSide = function getRangeSide(node /*: Node*/, nodeStartColumn /*: number*/, sideColumn /*: number*/) {\n          var side = null;\n          var nodeCharLength /*: number*/ = 0;\n          // if (node instanceof Text) {\n          if (node instanceof Text) {\n            nodeCharLength = node.length;\n          }\n\n          var nodeEndColumn = nodeStartColumn + nodeCharLength;\n\n          if (sideColumn >= nodeStartColumn && sideColumn <= nodeEndColumn) {\n            // Found the text node where side column inside node\n            side = {\n              node: node,\n              offset: sideColumn - nodeStartColumn\n            };\n          }\n          // }\n\n          return side;\n        };\n\n        var _selection = this.editorState.selection;\n\n        if (!_selection) {\n          return;\n        }\n\n        var range = document.createRange(),\n            rangeStart /*: Position*/ = void 0,\n            rangeEnd /*: Position*/ = void 0;\n\n        if (this._isRangeReversed(_selection)) {\n          rangeStart = _selection.end;\n          rangeEnd = _selection.start;\n        } else {\n          rangeStart = _selection.start;\n          rangeEnd = _selection.end;\n        }\n\n        var rangeStartRowElement = this.getRowElementByIndex(rangeStart.row),\n            rangeEndRowElement = this.getRowElementByIndex(rangeEnd.row),\n            side1 = void 0,\n            side2 = void 0;\n\n        if (!rangeStartRowElement || !rangeEndRowElement) {\n          return;\n        }\n\n        // Set the range to the current cursor position to start with\n        range.setStart(rangeStartRowElement, 0);\n        range.collapse(true);\n\n        this._dfsTraverseNode(function (node /*: Node*/, row /*: number*/, column /*: number*/) {\n          if (node.childNodes.length === 0) {\n\n            if (!side1 && row === rangeStart.row) {\n              side1 = getRangeSide(node, column, rangeStart.column);\n              if (side1) {\n                range.setStart(side1.node, side1.offset);\n              }\n            }\n\n            if (!side2 && row === rangeEnd.row) {\n              side2 = getRangeSide(node, column, rangeEnd.column);\n              if (side2) {\n                range.setEnd(side2.node, side2.offset);\n              }\n            }\n\n            if (side1 && side2) {\n              return true;\n            }\n          }\n        });\n\n        var sel = window.getSelection();\n        sel.removeAllRanges();\n        sel.addRange(range);\n      }\n    }\n  }, {\n    key: 'getCursorPosition',\n    value: function getCursorPosition() /*: Position*/ {\n      var cursorPosition /*: Position*/ = { row: 0, column: 0 };\n\n      return cursorPosition;\n    }\n  }]);\n\n  return Lighditor;\n}();\n\nwindow.Lighditor = Lighditor;\n\n// goog.provide 'opa.utils.Editor'\n\n// goog.require 'opa.utils.expressionParser.Parser'\n// goog.require 'opa.utils.expressionParser.TokenTypes'\n\n// # Import your own editor parser\n// expressionParser = opa.utils.expressionParser.Parser\n// tokenTypes = opa.utils.expressionParser.TokenTypes\n\n// expressionParser('ADD_EXP  ([Field 1], [Field 2] )')\n\n// EditorClass =\n//   CONTAINER: 'opaEditorContainer'\n//   INPUT: 'opaEditorInput'\n//   INPUT_MASK: 'opaEditorInputMask'\n\n// class Editor\n\n//   constructor: (@prop = {}) ->\n//     @inputElement = @prop.inputElement\n\n//     @resetRender()\n//     @buildEditor()\n//     @listen()\n//     @attachListeners()\n\n//   resetRender: () ->\n//     @renderedHtml = ''\n//     @parenthesisId = 0\n//     @processPos = 0\n//     @openParenthesis = []\n\n//   buildEditor: () ->\n//     # Error checks\n//     if not @inputElement\n//       throw new Error 'Missing input element for editor'\n\n//     wrapperElement = document.createElement 'div'\n//     wrapperElement.classList.add EditorClass.CONTAINER\n\n//     # Replace with input element\n//     @inputElement.parentNode.replaceChild wrapperElement, @inputElement\n//     @inputElement.classList.add EditorClass.INPUT\n//     # Make sure the original input is not shown\n//     @inputElement.style.display = 'none'\n//     wrapperElement.appendChild @inputElement\n\n//     # Create the autocomplete input mask\n//     @inputMask = document.createElement 'div'\n//     @inputMask.classList.add EditorClass.INPUT_MASK\n//     # Make the HTML div element editable\n//     @inputMask.setAttribute 'contenteditable', true\n//     # Sync with input text\n//     @setText @inputElement.value\n//     wrapperElement.appendChild @inputMask\n\n//   listen: () =>\n//     @inputMask.addEventListener 'keydown', @handleInputMaskKeydown\n//     @inputMask.addEventListener 'keyup', @handleInputMaskKeyup\n//     @inputElement.addEventListener 'change', @handleInputElementChange\n\n//   attachListeners: () ->\n//     # Make sure the listeners are attached from the constructor\n//     for eventName, eventHandler of @prop.eventHandlers\n//       @inputMask.addEventListener eventName, eventHandler\n\n//   # Event handlerseiejccfnkblfnvcfivcgndbrbjefiirgnejtinujjked\n//   handleInputMaskKeydown: () =>\n//     @syncMaskWithInput()\n\n//   handleInputMaskKeyup: () =>\n//     @syncMaskWithInput()\n//     @processContent()\n\n//   handleInputElementChange: () =>\n//     newValue = @inputElement.value\n//     # We need to make sure after each change, the input element\n//     # and the mask have same results. We already handled the\n//     # mask -> input flow. Here we handle the other flow\n//     @setText(newValue) if newValue isnt @inputMask.innerText\n\n//   # Utils\n//   syncMaskWithInput: () =>\n//     # Copy the text from input mask to the input element\n//     @inputElement.value = @inputMask.innerText\n\n//   # Render content logic\n//   # convert the content text into html based on parsed result\n//   processContent: (contentText = @inputMask.innerText) =>\n//     @saveSelection()\n//     @resetRender()\n//     parsed = expressionParser contentText\n//     @renderContent parsed\n//     @inputMask.innerHTML = @renderedHtml\n//     @restoreSelection()\n\n//   getSpaceHtml: (numOfSpace = 0) ->\n//     return '' if numOfSpace is 0\n//     spaceHtml = '''<span class=\"editorSpace\">'''\n//     while numOfSpace > 0\n//       spaceHtml += ' '\n//       numOfSpace--\n//     spaceHtml += '''</span>'''\n//     return spaceHtml\n\n//   addSpaceHtmlBefore: (node) =>\n//     if @processPos < node.charFrom\n//       @renderedHtml += @getSpaceHtml(node.charFrom - @processPos)\n//       @processPos = node.charFrom\n\n//   addSpaceHtmlAfter: (node) =>\n//     if @processPos < node.charTo\n//       @renderedHtml += @getSpaceHtml(node.charTo - @processPos)\n//       @processPos = node.charTo\n\n//   addParenthesis: () ->\n//     @renderedHtml += \"\"\"<span class=\"editorOpenParenthesis\" data-parenthesis-id=\"#{@parenthesisId}\">(</span>\"\"\"\n//     @openParenthesis.push parenthesisId\n//     @parenthesisId++\n\n//   removeParenthesis: (parenthesisElement) ->\n//     parenthesisId = parenthesisElement.dataset.parenthesisId\n//     unless _.isUndefined(parenthesisId)\n//       allParenthesis = @inputMask.querySelectorAll \"[data-parenthesis-id='#{parenthesisId}']\"\n//       @inputMask.removeChild child for child in allParenthesis\n\n//   renderChildren: (children) =>\n//     sortedNodes = _.sortBy children, (node) -> return node.charFrom\n//     # Render each node in the order of char from\n//     for node in sortedNodes\n//       @addSpaceHtmlBefore node\n//       @renderContent node\n\n//   renderContent: (parsedNode) =>\n//     @addSpaceHtmlBefore parsedNode\n\n//     switch parsedNode.type\n//       when tokenTypes.COMPOUND\n//         @renderChildren parsedNode.body\n//         @addSpaceHtmlAfter parsedNode\n\n//       when tokenTypes.CALL_EXP\n//         # First render callee\n//         callee = parsedNode.callee\n//         @addSpaceHtmlBefore callee\n//         @renderContent callee\n\n//         # Render '('\n//         addParenthesis()\n\n//         # Render the arguments\n//         @renderChildren parsedNode.arguments.list\n//         @addSpaceHtmlAfter parsedNode\n\n//       when tokenTypes.LITERAL, tokenTypes.NUMERIC_LITERAL, tokenTypes.STRING_LITERAL\n//         @renderedHtml += \"\"\"\n//           <span class=\"editorToken editor#{parsedNode.type}\" data-char-from=\"#{parsedNode.charFrom}\" data-char-to=\"#{parsedNode.charTo}\">#{parsedNode.raw}</span>\n//         \"\"\"\n\n//       when tokenTypes.IDENTIFIER\n//         @renderedHtml += \"\"\"\n//           <span class=\"editorToken editor#{parsedNode.type}\"  data-char-from=\"#{parsedNode.charFrom}\" data-char-to=\"#{parsedNode.charTo}\">#{parsedNode.name}</span>\n//         \"\"\"\n\n//     @processPos = parsedNode.charTo\n\n//   # DOM element getter\n//   getContainer: () => @inputMask.parentNode\n\n//   # Cursor related\n//   getCaretPosition: () =>\n//     # caretPos = 0\n\n//     # if sel = window.getSelection?()\n//     #   if sel.rangeCount\n//     #     range = sel.getRangeAt(0)\n//     #     caretPos = range.endOffset if range.commonAncestorContainer.parentNode is @inputMask\n\n//     # return caretPos\n\n//     currentSelection = @getSelection()\n//     if currentSelection\n//       return currentSelection.end\n//     else return 0\n\n//   setCaretPosition: (cursorPosition) =>\n//     # if (sel = window.getSelection?()) and (range = document.createRange?()) and @inputMask.childNodes[0]\n//     #   range.setStart node, cursorPosition\n//     #   range.collapse true\n//     #   sel.removeAllRanges()\n//     #   sel.addRange range\n//     #   @inputMask.focus()\n\n//     if _.isUndefined cursorPosition\n//       if @selection\n//         cursorStartPosition = @selection.start\n//         cursorEndPosition = @selection.end\n//       else if currentSelection = @getSelection()\n//         cursorStartPosition = currentSelection.start\n//         cursorEndPosition = currentSelection.end\n//     else\n//       cursorStartPosition = cursorPosition\n//       cursorEndPosition = cursorPosition\n\n//     selection =\n//       start: cursorStartPosition\n//       end: cursorEndPosition\n\n//     @restoreSelection selection\n\n//   getHtmlNodeUnderCursor: () ->\n//     return sel.focusNode if sel = window.getSelection?()\n\n//   _getNodeStartPos: () ->\n//     if (sel = window.getSelection?()) and document.createRange?\n//       return -1 unless focusNode = sel.focusNode\n\n//       preSelectionRange = document.createRange()\n//       preSelectionRange.selectNodeContents @inputMask\n//       preSelectionRange.setEnd focusNode, 0\n//       return preSelectionRange.toString().length\n\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n//       return -1\n\n//   getNodePosUnderCursor: () =>\n//     if (sel = window.getSelection?()) and document.createRange?\n//       return null unless focusNode = sel.focusNode\n\n//       start = @_getNodeStartPos()\n//       return null unless start >= 0\n\n//     # if (sel = window.getSelection?()) and document.createRange?\n//     #   return null unless focusNode = sel.focusNode\n\n//     #   preSelectionRange = document.createRange()\n//     #   preSelectionRange.selectNodeContents @inputMask\n//     #   preSelectionRange.setEnd focusNode, 0\n//     #   start = preSelectionRange.toString().length\n\n//       return {\n//         start: start\n//         end: start + focusNode.toString().length\n//       }\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n//       return null\n\n//   # Get the current selection and cursor position\n//   # REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n//   getSelection: () =>\n//     if (sel = window.getSelection?()) and document.createRange?\n//       return @selection = null unless sel.focusNode\n\n//       range = sel.getRangeAt(0)\n//       selectionStartPos = @_getNodeStartPos()\n\n//       if selectionStartPos >= 0\n//         start = selectionStartPos + range.startOffset\n//         return {\n//           start: start\n//           end: start + range.toString().length\n//         }\n//       else\n//         return null\n\n//       # preSelectionRange = range.cloneRange()\n//       # preSelectionRange.selectNodeContents @inputMask\n//       # preSelectionRange.setEnd range.startContainer, range.startOffset\n//       # start = preSelectionRange.toString().length\n\n//       # return {\n//       #   start: start\n//       #   end: start + range.toString().length\n//       # }\n\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n//       return null\n\n//   # Save the current selection and cursor position\n//   # REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n//   saveSelection: () => @selection = @getSelection()\n\n//   # Restore the saved selection and cursor position\n//   # REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n//   restoreSelection: (selection = @selection) =>\n//     if window.getSelection? and document.createRange?\n//       return unless selection\n\n//       charIndex = 0\n//       range = document.createRange()\n//       range.setStart @inputMask, 0\n//       range.collapse true\n\n//       nodeStack = [@inputMask]\n//       foundStart = false\n//       stop = false\n\n//       while (not stop and (node = nodeStack.pop()))\n//         if node.nodeType is window.Node.TEXT_NODE\n//           nextCharIndex = charIndex + node.length\n//           if not foundStart and selection.start >= charIndex and selection.start <= nextCharIndex\n//             range.setStart node, selection.start - charIndex\n//             foundStart = true\n\n//           if foundStart && selection.end >= charIndex && selection.end <= nextCharIndex\n//             range.setEnd(node, selection.end - charIndex)\n//             stop = true\n\n//           charIndex = nextCharIndex\n\n//         else\n//           children = node.childNodes\n//           nodeIndex = children.length\n//           while nodeIndex--\n//             nodeStack.push children[nodeIndex]\n\n//       sel = window.getSelection()\n//       sel.removeAllRanges()\n//       sel.addRange range\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n\n//     @selection = null\n\n//   getNodeUnderCursor: (cursorPosition) ->\n//     if window.getSelection? and document.createRange?\n//       sel = window.getSelection()\n\n\n//   # # Set the selection to be previous word under cursor\n//   # getWordSelectionUnderCursor: (fullString, cursorPosition) ->\n//   #   preWordRegexp = /^.*?\\s*([^\\s]*)$/ # Lazy matching\n//   #   postWordRegexp = /^([^\\s]*)\\s*.*$/\n//   #   preWord = fullString.slice 0, cursorPosition\n//   #   postWord = fullString.slice cursorPosition\n\n//   #   preMatches = preWord.match preWordRegexp\n//   #   postMatches = postWord.match postWordRegexp\n\n//   #   # There should always be matches for both pre and post matches\n//   #   return null if not preMatches or not postMatches\n\n//   #   start: cursorPosition - preMatches[1].length\n//   #   end: cursorPosition + postMatches[1].length\n//   #   selectedText: preMatches[1] + postMatches[1]\n//   #   fullText: fullString\n\n//   # Editor operation\n//   # setText: (editableElement, cursorPosition, textObj, setType) ->\n//   # Set the focused word to be update\n//   # The focused word is the same to selection if selection exists.\n//   # Otherwise it is the node where under the cursor\n//   setFocusedWord: () =>\n//     @focusedWord = @getSelection()\n\n//     # if currentSelection.start is currentSelection.end\n//     #   @focusedWord = @getNodePosUnderCursor()\n//     # else\n//     #   @focusedWord = currentSelection\n\n//   # The defination of focused word is the word to be updated\n//   # In most case it's the same to selection, but in some cases\n//   # we want to update the un-selected words (to be supported)\n//   updateFocusedWord: (wordToUpdate) =>\n//     return unless wordToUpdate\n\n//     if @focusedWord\n//       oldString = @inputMask.innerText\n//       newString = oldString.slice(0, @focusedWord.start) \\\n//         + wordToUpdate \\\n//         + oldString.slice(@focusedWord.end)\n//       @setCaretPosition @focusedWord.start + wordToUpdate.length\n//       @setText newString\n//     else\n//       @setCaretPosition @inputMask.innerText.length + wordToUpdate.length\n//       # Append the focusedWord name into autocomplete input box\n//       # Only append the remaining strings to complete typing\n//       @setText(@inputMask.innerText + wordToUpdate)\n\n//     @syncMaskWithInput()\n\n//   setText: (contentText) =>\n//     # @inputMask.innerText = contentText\n//     @processContent contentText\n\n//   getText: () => @inputMask.innerText\n//   focusEditor: () =>\n//     @inputMask.focus()\n\n// opa.utils.Editor = Editor\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lighditor.js\n// module id = 1\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./lighditor.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./lighditor.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./lighditor.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lighditor.scss\n// module id = 2\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".lighditorElement {\\n  height: 200px;\\n  outline: none;\\n  border: 1px solid black; }\\n  .lighditorElement .lighditorRow {\\n    font-family: courier;\\n    height: 14px;\\n    line-height: 14px; }\\n\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/lighditor.scss\n// module id = 3\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader/lib/css-base.js\n// module id = 4\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/addStyles.js\n// module id = 5\n// module chunks = 0","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/urls.js\n// module id = 6\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5iCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}