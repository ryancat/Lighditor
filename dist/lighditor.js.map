{"version":3,"file":"lighditor.js","sources":["webpack:///webpack/bootstrap 336c2a340e7106d33822","webpack:///./src/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 336c2a340e7106d33822","'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Web editor should support\n// 1. Basic type in editor\n// 2. Get/Set cursor position\n// 3. Get/Set selection\n// 4. Get/Set text content\n// 5.\n//\n\n/*:: type Position = {\n  row: number,\n  column: number\n}*/\n/*:: type Selection = {\n  start: Position,\n  end: Position\n}*/\n/*:: type LighditorConfig = {\n  initTextContent: string\n}*/\n/*:: type LighditorProps = {\n  element: HTMLElement,\n  config: ?LighditorConfig\n}*/\n/*:: type LighditorState = {\n  textContent: string,\n  cursorPosition: Position,\n  selection: {\n    start: Position,\n    end: Position\n  }\n}*/\n\n\nvar EditorClass = {\n  CONTAINER: 'lighditorContainer',\n  ELEMENT: 'lighditorRawElement',\n  EDITOR_ELEMENT: 'lighditorElement'\n};\n\nvar positionTypeEnum = {\n  START: 'start',\n  END: 'end'\n};\n\n/*:: type PositionTypeEnum = $Keys<typeof positionTypeEnum>*/\n\n\nvar ERROR_POSITION /*: Position*/ = {\n  row: -1,\n  column: -1\n\n  // Feature detection\n};var featureGetSelection = !!window.getSelection;\nvar featureCreateRange = !!document.createRange;\n\nvar Lighditor = function () {\n  function Lighditor(props /*: LighditorProps*/) {\n    _classCallCheck(this, Lighditor);\n\n    this.element = props.element;\n    this.editorConfig = props.config || {\n      initTextContent: ''\n\n      // this.resetRender()\n      // this.build()\n      // this.listen()\n      // @attachListeners()\n      //\n\n    };\n  }\n\n  _createClass(Lighditor, [{\n    key: 'resetRender',\n    value: function resetRender() /*: void*/ {\n      this.setEditorState({\n        textContent: '',\n        cursorPosition: { row: 0, column: 0 },\n        selection: {\n          start: { row: 0, column: 0 },\n          end: { row: 0, column: 0 }\n        }\n      });\n    }\n  }, {\n    key: 'build',\n    value: function build(config /*: ?LighditorConfig*/) {\n      // Error checks\n      if (typeof this.element === 'undefined') {\n        throw new Error('Missing element for editor');\n      }\n\n      var elementParent = this.element.parentElement;\n      if (!elementParent) {\n        throw new Error('Element set to html document is not supported');\n      }\n\n      // Update config\n      if (typeof config !== 'undefined') {\n        for (var key in config) {\n          if (config.hasOwnProperty(key)) {\n            this.editorConfig[key] = config[key];\n          }\n        }\n      }\n\n      var wrapperElement /*: HTMLDivElement*/ = document.createElement('div');\n      wrapperElement.classList.add(EditorClass.CONTAINER);\n\n      // Replace with input element\n      elementParent.replaceChild(wrapperElement, this.element);\n      this.element.classList.add(EditorClass.ELEMENT);\n\n      // Make sure the original element is not shown\n      this.element.style.display = 'none';\n      wrapperElement.appendChild(this.element);\n\n      // Create editor\n      this.editorElement = document.createElement('div');\n      this.editorElement.classList.add(EditorClass.EDITOR_ELEMENT);\n\n      // Make editor element editable\n      this.editorElement.setAttribute('contenteditable', 'true');\n      wrapperElement.appendChild(this.editorElement);\n\n      // Reset editor state\n      this.resetRender();\n\n      // Attach listeners\n      this.listen();\n\n      // Setup placeholder or init text\n      this.setTextContent(this.editorConfig.initTextContent || '');\n    }\n  }, {\n    key: 'listen',\n    value: function listen() /*: void*/ {\n      this.editorElement.addEventListener('keydown', this.handleKeydown.bind(this));\n      this.editorElement.addEventListener('keyup', this.handleKeyup.bind(this));\n    }\n\n    /***** Event handlers *****/\n\n  }, {\n    key: 'handleKeydown',\n    value: function handleKeydown(evt /*: KeyboardEvent*/) {}\n  }, {\n    key: 'handleKeyup',\n    value: function handleKeyup(evt /*: KeyboardEvent*/) {\n      // TODO: We may not need to update the whole editor text content\n      // but only the section that is actually changed\n      // this.saveSelection()\n      this.setTextContent(this.editorElement.textContent);\n      // this.restoreSelection()\n\n      // TODO: update selection if arrow key is up\n    }\n  }, {\n    key: 'handleMouseup',\n    value: function handleMouseup(evt /*: MouseEvent*/) {\n      this.updateSelection();\n    }\n\n    /***** Lifecycle events *****/\n    /**\n     * Called after text content is changed\n     */\n\n  }, {\n    key: 'onTextContentChange',\n    value: function onTextContentChange(newTextContent /*: string*/, oldTextContent /*: string*/) /*: void*/ {}\n\n    /**\n     * Called after selection is changed\n     */\n\n  }, {\n    key: 'onSelectionChange',\n    value: function onSelectionChange(newSelection /*: Selection*/, oldSelection /*: Selection*/) /*: void*/ {}\n\n    /***** Setters *****/\n\n  }, {\n    key: 'setEditorState',\n    value: function setEditorState(editorState /*: LighditorState*/) /*: void*/ {\n      console.log('calling setEditorState: ', editorState);\n\n      this.editorState = _extends({}, editorState);\n    }\n  }, {\n    key: 'setTextContent',\n    value: function setTextContent(textContent /*: string*/) /*: void*/ {\n      var oldTextContent = this.editorState.textContent;\n\n      this.setEditorState(_extends({}, this.editorState, {\n        textContent: textContent\n      }));\n\n      this.onTextContentChange(textContent, oldTextContent);\n    }\n  }, {\n    key: 'setSelection',\n    value: function setSelection(selection /*: Selection*/) /*: void*/ {\n      var oldSelection = this.editorState.selection;\n\n      this.setEditorState(_extends({}, this.editorState, {\n        selection: selection\n      }));\n\n      this.onSelectionChange(selection, oldSelection);\n    }\n\n    /***** Cursor and selection *****/\n\n  }, {\n    key: 'getSelection',\n    value: function getSelection() /*: Selection*/ {\n      return this.editorState.selection;\n    }\n\n    /**\n     * Recursively goes up and get the row node from current node\n     */\n\n  }, {\n    key: '_getParentRowNode',\n    value: function _getParentRowNode(node /*: HTMLElement*/) /*: ?HTMLElement*/ {\n      var runningNode = node;\n\n      while (runningNode && runningNode !== this.editorElement && !runningNode.dataset['lighditorType'] === 'row') {\n        runningNode = runningNode.parentElement;\n      }\n\n      if (runningNode && runningNode instanceof HTMLElement) {\n        return runningNode;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: '_getSelectionNodePosition',\n    value: function _getSelectionNodePosition(positionType /*: PositionTypeEnum*/) /*: ?Position*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var currentSelection = window.getSelection();\n        var node /*: HTMLElement*/ = void 0;\n\n        switch (positionType) {\n          case 'START':\n            node = currentSelection.anchorNode;\n            break;\n\n          case 'END':\n            node = currentSelection.focusNode;\n            break;\n\n          default:\n            node = currentSelection.focusNode;\n        }\n\n        if (!node) {\n          return null;\n        }\n\n        var rowNode = this._getParentRowNode(node);\n\n        if (!rowNode) {\n          return null;\n        }\n\n        var rangeBefore = document.createRange();\n        rangeBefore.selectNodeContents(rowNode);\n        rangeBefore.setEnd(node, 0);\n\n        return {\n          row: +rowNode.dataset['row'],\n          column: rangeBefore.toString().length\n        };\n      } else {\n        // TODO: add support for old IE\n        return null;\n      }\n    }\n\n    /**\n     * Get the current selection's start position\n     */\n\n  }, {\n    key: '_getSelectionStartNodePosition',\n    value: function _getSelectionStartNodePosition() /*: ?Position*/ {\n      return this._getSelectionNodePosition('START');\n    }\n\n    /**\n     * Get the current selection's end position\n     */\n\n  }, {\n    key: '_getSelectionEndNodePosition',\n    value: function _getSelectionEndNodePosition() /*: ?Position*/ {\n      return this._getSelectionNodePosition('END');\n    }\n\n    /**\n     * Update the selection state from user interaction\n     */\n\n  }, {\n    key: 'updateSelection',\n    value: function updateSelection() /*: void*/ {\n      if (featureGetSelection && featureCreateRange) {\n        var currentSelection = window.getSelection();\n\n        if (!currentSelection.focusNode) {\n          return;\n        }\n\n        var range = currentSelection.getRangeAt(0);\n        var selectionStartPosition /*: ?Position*/ = this._getSelectionStartNodePosition();\n        var selectionEndPosition /*: ?Position*/ = this._getSelectionEndNodePosition();\n\n        if (selectionStartPosition && selectionEndPosition) {\n          this.setSelection({\n            start: {\n              row: selectionStartPosition.row,\n              column: selectionStartPosition.column + range.startOffset\n            },\n            end: {\n              row: selectionEndPosition.row,\n              column: selectionEndPosition.column + range.endOffset\n            }\n          });\n        }\n      } else {}\n      // TODO: add support for old IE\n\n\n      // if (sel = window.getSelection?()) and document.createRange?\n      //   return @selection = null unless sel.focusNode\n\n      //   range = sel.getRangeAt(0)\n      //   selectionStartPos = @_getNodeStartPos()\n\n      //   if selectionStartPos >= 0\n      //     start = selectionStartPos + range.startOffset\n      //     return {\n      //       start: start\n      //       end: start + range.toString().length\n      //     }\n      //   else\n      //     return null\n\n      //   # preSelectionRange = range.cloneRange()\n      //   # preSelectionRange.selectNodeContents @inputMask\n      //   # preSelectionRange.setEnd range.startContainer, range.startOffset\n      //   # start = preSelectionRange.toString().length\n\n      //   # return {\n      //   #   start: start\n      //   #   end: start + range.toString().length\n      //   # }\n\n      // else\n      //   console.warn 'Editor selection persist feature does not support'\n      //   return null\n    }\n  }, {\n    key: 'saveSelection',\n    value: function saveSelection() /*: void*/ {}\n  }, {\n    key: 'restoreSelection',\n    value: function restoreSelection(selection /*: Selection*/) /*: void*/ {}\n  }, {\n    key: 'getCursorPosition',\n    value: function getCursorPosition() /*: Position*/ {\n      var cursorPosition /*: Position*/ = { row: 0, column: 0 };\n\n      return cursorPosition;\n    }\n  }]);\n\n  return Lighditor;\n}();\n\nwindow.Lighditor = Lighditor;\n\n// goog.provide 'opa.utils.Editor'\n\n// goog.require 'opa.utils.expressionParser.Parser'\n// goog.require 'opa.utils.expressionParser.TokenTypes'\n\n// # Import your own editor parser\n// expressionParser = opa.utils.expressionParser.Parser\n// tokenTypes = opa.utils.expressionParser.TokenTypes\n\n// expressionParser('ADD_EXP  ([Field 1], [Field 2] )')\n\n// EditorClass =\n//   CONTAINER: 'opaEditorContainer'\n//   INPUT: 'opaEditorInput'\n//   INPUT_MASK: 'opaEditorInputMask'\n\n// class Editor\n\n//   constructor: (@prop = {}) ->\n//     @inputElement = @prop.inputElement\n\n//     @resetRender()\n//     @buildEditor()\n//     @listen()\n//     @attachListeners()\n\n//   resetRender: () ->\n//     @renderedHtml = ''\n//     @parenthesisId = 0\n//     @processPos = 0\n//     @openParenthesis = []\n\n//   buildEditor: () ->\n//     # Error checks\n//     if not @inputElement\n//       throw new Error 'Missing input element for editor'\n\n//     wrapperElement = document.createElement 'div'\n//     wrapperElement.classList.add EditorClass.CONTAINER\n\n//     # Replace with input element\n//     @inputElement.parentNode.replaceChild wrapperElement, @inputElement\n//     @inputElement.classList.add EditorClass.INPUT\n//     # Make sure the original input is not shown\n//     @inputElement.style.display = 'none'\n//     wrapperElement.appendChild @inputElement\n\n//     # Create the autocomplete input mask\n//     @inputMask = document.createElement 'div'\n//     @inputMask.classList.add EditorClass.INPUT_MASK\n//     # Make the HTML div element editable\n//     @inputMask.setAttribute 'contenteditable', true\n//     # Sync with input text\n//     @setText @inputElement.value\n//     wrapperElement.appendChild @inputMask\n\n//   listen: () =>\n//     @inputMask.addEventListener 'keydown', @handleInputMaskKeydown\n//     @inputMask.addEventListener 'keyup', @handleInputMaskKeyup\n//     @inputElement.addEventListener 'change', @handleInputElementChange\n\n//   attachListeners: () ->\n//     # Make sure the listeners are attached from the constructor\n//     for eventName, eventHandler of @prop.eventHandlers\n//       @inputMask.addEventListener eventName, eventHandler\n\n//   # Event handlerseiejccfnkblfnvcfivcgndbrbjefiirgnejtinujjked\n//   handleInputMaskKeydown: () =>\n//     @syncMaskWithInput()\n\n//   handleInputMaskKeyup: () =>\n//     @syncMaskWithInput()\n//     @processContent()\n\n//   handleInputElementChange: () =>\n//     newValue = @inputElement.value\n//     # We need to make sure after each change, the input element\n//     # and the mask have same results. We already handled the\n//     # mask -> input flow. Here we handle the other flow\n//     @setText(newValue) if newValue isnt @inputMask.innerText\n\n//   # Utils\n//   syncMaskWithInput: () =>\n//     # Copy the text from input mask to the input element\n//     @inputElement.value = @inputMask.innerText\n\n//   # Render content logic\n//   # convert the content text into html based on parsed result\n//   processContent: (contentText = @inputMask.innerText) =>\n//     @saveSelection()\n//     @resetRender()\n//     parsed = expressionParser contentText\n//     @renderContent parsed\n//     @inputMask.innerHTML = @renderedHtml\n//     @restoreSelection()\n\n//   getSpaceHtml: (numOfSpace = 0) ->\n//     return '' if numOfSpace is 0\n//     spaceHtml = '''<span class=\"editorSpace\">'''\n//     while numOfSpace > 0\n//       spaceHtml += ' '\n//       numOfSpace--\n//     spaceHtml += '''</span>'''\n//     return spaceHtml\n\n//   addSpaceHtmlBefore: (node) =>\n//     if @processPos < node.charFrom\n//       @renderedHtml += @getSpaceHtml(node.charFrom - @processPos)\n//       @processPos = node.charFrom\n\n//   addSpaceHtmlAfter: (node) =>\n//     if @processPos < node.charTo\n//       @renderedHtml += @getSpaceHtml(node.charTo - @processPos)\n//       @processPos = node.charTo\n\n//   addParenthesis: () ->\n//     @renderedHtml += \"\"\"<span class=\"editorOpenParenthesis\" data-parenthesis-id=\"#{@parenthesisId}\">(</span>\"\"\"\n//     @openParenthesis.push parenthesisId\n//     @parenthesisId++\n\n//   removeParenthesis: (parenthesisElement) ->\n//     parenthesisId = parenthesisElement.dataset.parenthesisId\n//     unless _.isUndefined(parenthesisId)\n//       allParenthesis = @inputMask.querySelectorAll \"[data-parenthesis-id='#{parenthesisId}']\"\n//       @inputMask.removeChild child for child in allParenthesis\n\n//   renderChildren: (children) =>\n//     sortedNodes = _.sortBy children, (node) -> return node.charFrom\n//     # Render each node in the order of char from\n//     for node in sortedNodes\n//       @addSpaceHtmlBefore node\n//       @renderContent node\n\n//   renderContent: (parsedNode) =>\n//     @addSpaceHtmlBefore parsedNode\n\n//     switch parsedNode.type\n//       when tokenTypes.COMPOUND\n//         @renderChildren parsedNode.body\n//         @addSpaceHtmlAfter parsedNode\n\n//       when tokenTypes.CALL_EXP\n//         # First render callee\n//         callee = parsedNode.callee\n//         @addSpaceHtmlBefore callee\n//         @renderContent callee\n\n//         # Render '('\n//         addParenthesis()\n\n//         # Render the arguments\n//         @renderChildren parsedNode.arguments.list\n//         @addSpaceHtmlAfter parsedNode\n\n//       when tokenTypes.LITERAL, tokenTypes.NUMERIC_LITERAL, tokenTypes.STRING_LITERAL\n//         @renderedHtml += \"\"\"\n//           <span class=\"editorToken editor#{parsedNode.type}\" data-char-from=\"#{parsedNode.charFrom}\" data-char-to=\"#{parsedNode.charTo}\">#{parsedNode.raw}</span>\n//         \"\"\"\n\n//       when tokenTypes.IDENTIFIER\n//         @renderedHtml += \"\"\"\n//           <span class=\"editorToken editor#{parsedNode.type}\"  data-char-from=\"#{parsedNode.charFrom}\" data-char-to=\"#{parsedNode.charTo}\">#{parsedNode.name}</span>\n//         \"\"\"\n\n//     @processPos = parsedNode.charTo\n\n//   # DOM element getter\n//   getContainer: () => @inputMask.parentNode\n\n//   # Cursor related\n//   getCaretPosition: () =>\n//     # caretPos = 0\n\n//     # if sel = window.getSelection?()\n//     #   if sel.rangeCount\n//     #     range = sel.getRangeAt(0)\n//     #     caretPos = range.endOffset if range.commonAncestorContainer.parentNode is @inputMask\n\n//     # return caretPos\n\n//     currentSelection = @getSelection()\n//     if currentSelection\n//       return currentSelection.end\n//     else return 0\n\n//   setCaretPosition: (cursorPosition) =>\n//     # if (sel = window.getSelection?()) and (range = document.createRange?()) and @inputMask.childNodes[0]\n//     #   range.setStart node, cursorPosition\n//     #   range.collapse true\n//     #   sel.removeAllRanges()\n//     #   sel.addRange range\n//     #   @inputMask.focus()\n\n//     if _.isUndefined cursorPosition\n//       if @selection\n//         cursorStartPosition = @selection.start\n//         cursorEndPosition = @selection.end\n//       else if currentSelection = @getSelection()\n//         cursorStartPosition = currentSelection.start\n//         cursorEndPosition = currentSelection.end\n//     else\n//       cursorStartPosition = cursorPosition\n//       cursorEndPosition = cursorPosition\n\n//     selection =\n//       start: cursorStartPosition\n//       end: cursorEndPosition\n\n//     @restoreSelection selection\n\n//   getHtmlNodeUnderCursor: () ->\n//     return sel.focusNode if sel = window.getSelection?()\n\n//   _getNodeStartPos: () ->\n//     if (sel = window.getSelection?()) and document.createRange?\n//       return -1 unless focusNode = sel.focusNode\n\n//       preSelectionRange = document.createRange()\n//       preSelectionRange.selectNodeContents @inputMask\n//       preSelectionRange.setEnd focusNode, 0\n//       return preSelectionRange.toString().length\n\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n//       return -1\n\n//   getNodePosUnderCursor: () =>\n//     if (sel = window.getSelection?()) and document.createRange?\n//       return null unless focusNode = sel.focusNode\n\n//       start = @_getNodeStartPos()\n//       return null unless start >= 0\n\n//     # if (sel = window.getSelection?()) and document.createRange?\n//     #   return null unless focusNode = sel.focusNode\n\n//     #   preSelectionRange = document.createRange()\n//     #   preSelectionRange.selectNodeContents @inputMask\n//     #   preSelectionRange.setEnd focusNode, 0\n//     #   start = preSelectionRange.toString().length\n\n//       return {\n//         start: start\n//         end: start + focusNode.toString().length\n//       }\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n//       return null\n\n//   # Get the current selection and cursor position\n//   # REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n//   getSelection: () =>\n//     if (sel = window.getSelection?()) and document.createRange?\n//       return @selection = null unless sel.focusNode\n\n//       range = sel.getRangeAt(0)\n//       selectionStartPos = @_getNodeStartPos()\n\n//       if selectionStartPos >= 0\n//         start = selectionStartPos + range.startOffset\n//         return {\n//           start: start\n//           end: start + range.toString().length\n//         }\n//       else\n//         return null\n\n//       # preSelectionRange = range.cloneRange()\n//       # preSelectionRange.selectNodeContents @inputMask\n//       # preSelectionRange.setEnd range.startContainer, range.startOffset\n//       # start = preSelectionRange.toString().length\n\n//       # return {\n//       #   start: start\n//       #   end: start + range.toString().length\n//       # }\n\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n//       return null\n\n//   # Save the current selection and cursor position\n//   # REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n//   saveSelection: () => @selection = @getSelection()\n\n//   # Restore the saved selection and cursor position\n//   # REF: https://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html\n//   restoreSelection: (selection = @selection) =>\n//     if window.getSelection? and document.createRange?\n//       return unless selection\n\n//       charIndex = 0\n//       range = document.createRange()\n//       range.setStart @inputMask, 0\n//       range.collapse true\n\n//       nodeStack = [@inputMask]\n//       foundStart = false\n//       stop = false\n\n//       while (not stop and (node = nodeStack.pop()))\n//         if node.nodeType is window.Node.TEXT_NODE\n//           nextCharIndex = charIndex + node.length\n//           if not foundStart and selection.start >= charIndex and selection.start <= nextCharIndex\n//             range.setStart node, selection.start - charIndex\n//             foundStart = true\n\n//           if foundStart && selection.end >= charIndex && selection.end <= nextCharIndex\n//             range.setEnd(node, selection.end - charIndex)\n//             stop = true\n\n//           charIndex = nextCharIndex\n\n//         else\n//           children = node.childNodes\n//           nodeIndex = children.length\n//           while nodeIndex--\n//             nodeStack.push children[nodeIndex]\n\n//       sel = window.getSelection()\n//       sel.removeAllRanges()\n//       sel.addRange range\n//     else\n//       console.warn 'Editor selection persist feature does not support'\n\n//     @selection = null\n\n//   getNodeUnderCursor: (cursorPosition) ->\n//     if window.getSelection? and document.createRange?\n//       sel = window.getSelection()\n\n\n//   # # Set the selection to be previous word under cursor\n//   # getWordSelectionUnderCursor: (fullString, cursorPosition) ->\n//   #   preWordRegexp = /^.*?\\s*([^\\s]*)$/ # Lazy matching\n//   #   postWordRegexp = /^([^\\s]*)\\s*.*$/\n//   #   preWord = fullString.slice 0, cursorPosition\n//   #   postWord = fullString.slice cursorPosition\n\n//   #   preMatches = preWord.match preWordRegexp\n//   #   postMatches = postWord.match postWordRegexp\n\n//   #   # There should always be matches for both pre and post matches\n//   #   return null if not preMatches or not postMatches\n\n//   #   start: cursorPosition - preMatches[1].length\n//   #   end: cursorPosition + postMatches[1].length\n//   #   selectedText: preMatches[1] + postMatches[1]\n//   #   fullText: fullString\n\n//   # Editor operation\n//   # setText: (editableElement, cursorPosition, textObj, setType) ->\n//   # Set the focused word to be update\n//   # The focused word is the same to selection if selection exists.\n//   # Otherwise it is the node where under the cursor\n//   setFocusedWord: () =>\n//     @focusedWord = @getSelection()\n\n//     # if currentSelection.start is currentSelection.end\n//     #   @focusedWord = @getNodePosUnderCursor()\n//     # else\n//     #   @focusedWord = currentSelection\n\n//   # The defination of focused word is the word to be updated\n//   # In most case it's the same to selection, but in some cases\n//   # we want to update the un-selected words (to be supported)\n//   updateFocusedWord: (wordToUpdate) =>\n//     return unless wordToUpdate\n\n//     if @focusedWord\n//       oldString = @inputMask.innerText\n//       newString = oldString.slice(0, @focusedWord.start) \\\n//         + wordToUpdate \\\n//         + oldString.slice(@focusedWord.end)\n//       @setCaretPosition @focusedWord.start + wordToUpdate.length\n//       @setText newString\n//     else\n//       @setCaretPosition @inputMask.innerText.length + wordToUpdate.length\n//       # Append the focusedWord name into autocomplete input box\n//       # Only append the remaining strings to complete typing\n//       @setText(@inputMask.innerText + wordToUpdate)\n\n//     @syncMaskWithInput()\n\n//   setText: (contentText) =>\n//     # @inputMask.innerText = contentText\n//     @processContent contentText\n\n//   getText: () => @inputMask.innerText\n//   focusEditor: () =>\n//     @inputMask.focus()\n\n// opa.utils.Editor = Editor\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 1\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A","sourceRoot":""}